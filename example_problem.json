{
    "description": "an online contest will soon be held on forcecoders, a large competitive programming platform. the authors have prepared n problems and since the platform is very popular, 998244351 coder from all over the world is going to solve them.for each problem, the authors estimated the number of people who would solve it for the i -th problem, the number of accepted solutions will be between l i and r i , inclusive.the creator of forcecoders uses different criteria to determine if the contest is good or bad. one of these criteria is the number of inversions in the problem order. an inversion is a pair of problems x, y such that x is located earlier in the contest x lt y , but the number of accepted solutions for y is strictly greater.obviously, both the creator of forcecoders and the authors of the contest want the contest to be good. now they want to calculate the probability that there will be no inversions in the problem order, assuming that for each problem i , any integral number of accepted solutions for it between l i and r i is equally probable, and all these numbers are independent.",
    "code": "import sys from itertools import chain readline = sys.stdin.readline mod = 998244353 def compress l l2 = list set l l2.sort c = v k for k, v in enumerate l2 return l2, c n = int readline lr = tuple map int, readline .split for in range n lr = a-1, b for a, b in lr lr2 = lr ml = lr -1 0 res = 0 for i in range n-2, -1, -1 l, r = lr i if r <= ml break l = max ml, l ml = l lr i = l, r else z = list chain *lr z2, dc = compress z nn = len z2 seglen = 0 + n - p for p, n in zip z2, z2 1 hc = 0 * n+3 for in range nn for j in range nn hc j 0 = 1 for k in range 1, n+3 hc j k = hc j k-1 *pow k, mod-2, mod * seglen j -1+k mod mask = true *nn dp = 0 * n+1 for in range nn+1 for in range n+1 dp = 1 * nn+1 + 0 * nn+1 for in range n for i in range 1, n+1 mask2 = false *nn l, r = lr i-1 dl, dr = dc l , dc r for j in range dr, dl, -1 mask2 j = true mm = m1 m2 for m1, m2 in zip mask -1 idx , mask2 for idx in range i + mask2 mask.append mm for j in range nn for k in range 1, i+1 if mask i i-k+1 j dp i j k ="
}